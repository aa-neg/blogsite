---
layout: post
title:  "Microservices"
date: 2017-10-25 08:40:09 +1100
categories: nodejs, rust, kubernetes, docker 
---

Almost my entire day to day now is writing microservices (mainly nodejs) and setting up their orchestration. As an overall concept I love it. Seperation of concern and creating a development environment that requires many moving parts (not just from the microservice but dbs, frontends, backends etc) can easily be spun up, reproducable and shippable. There is a bit of a learning curve to this however and quite a bit of tooling to write and learn (hence the docker evaluation, helm etc) to ensure everything sits together and makes sense. 

A point of view I usually receive is that this is architecture is overly complicated and a monolithic app would have been simpler. This does have some merit, where before you would just throw in another folder to your app instead now (if it makes sense) you'll need to write the service and write more declarative code describing how your app sits together and what components it needs to function. However you are already doing so when writing the monolithic app, you are already deciding what this component depends on and where it sits. Writing microservices however makes this explicit. We really should be learning from the mistakes of prvious larger projects (look at windows OS) and have very clear interfaces and dependencies which can be reasoned with reproducable and most importnatly replaceable. 

I have been really enjoying writing the tooling set (initially just for my team but slowly introducing it to other teams) for the orchestration of development environments and the CI/CD. Theres a cli tool which will checkout a repo read through its dependencies then spawn up components you require (even going so far as to run specific db seeding scripts so you have data). In addition all builds run through a slack channel. This would seem standard however with the webhook button integration you can easily redeploy builds (which in turn gives you the option to redeploy all other components). This can easily be improved upon as we have set-up AWS SNS topics for various events which in the future i'm hoping to utlize in just a smarter developer experience such as knowing what parts you are currently working on and providing meaningful notifications. 

One advantage I hope to utilize is that now that everything is easily swappable is that realistically it doesn't really matter what language the service is written in. Theres a clean contract interface of what it needs to do and what input it takes (over HTTP). So i'm currently at the moment looking to find something to show a good use case for rust. Now currently all the tooling i've written is in rust and to be honest i'm still not very effective with the language. But it has been the most fun language I have ever utilized. I'll probably ramble on about my likes for the language after some more experience however the ability to control low level with the niceties of high level abstraction its no wonder why its the most loved language from the latest stackoverflow servey. Plus it goes straight into LLVM thats just awesome. 

So guess my entire point is that microservices might have a bit of a learning curve but with good tooling the developer experience is really good and it has been a joy not to work with this architecture. Now I don't believe this is the be all and end all but with the current state of technology where it is now with distirbuted cloud computing being king I do beieve it makes sense and has more benefits than negatives for most situations. 